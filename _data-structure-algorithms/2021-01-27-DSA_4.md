---
layout: data-structure-algorithms
title: Everything about Linked Lists
description: Chaining the elements at ease!
date:   2021-01-27 13:43:52 +0530
---
{% include mathjax.html %}
In this blog post, we'll learn everything about the linked list and its variants. We'll also implement different linked lists in python.

A linked list consists of a set of nodes connected together in sequence, where each node has two placeholders, 

* the First placeholder holds the element or data
* the Second placeholder holds the address of the next node

The first node is called **head** and the last node of the linked list is identified by having its second placeholder as **Null**.

<center>
<img src="{{site.url}}/assets/images/dsa/Linkedlist.png" style="zoom: 5%; background-color:#DCDCDC;" width="80%" height=auto/><br>
<p>Figure 1: Linked List</p> 
</center>

In Heap, max-heap, or min-heap, the insertion and deletion operation depends on the number of nodes getting swapped and maintaining the heap property simultaneously. The time complexity varies from *1* to *Log n.* However, in Linked List, **The insertion and deletion operation takes a constant time of 1.**

A linked list is a very important data structure as it helps in understanding other advanced data structures like trees and graphs.

**Simple Linked List Implementation**

```python

        class node:
            def __init__(self, item):
                self.data = item
                self.next = None

        class LinkedList:
            def __init__(self):
                self.head = None
                
        LL = LinkedList()
        LL.head = node(1)
        second_node = node(2)
        third_node = node(3)

        LL.head.next = second_node
        second_node.next = third_node

        between_node = node(2.5)
        between_node.next = third_node
        second_node.next = between_node

        while LL.head != None:
            print(LL.head.data, end=" ")
            LL.head = LL.head.next
            
        """
        1 2 2.5 3 
        """

```

**Applications**

* Hash Tables, Graphs, and stack.

**Operation in Linked List**

I've tried to implement the Insertion of all types, try out deletion.

* Insert a node at the beginning, at the middle, or at the last.
* Delete a node at the beginning, at the middle, or at last.

### Insertion

**Insertion at the beginning**

* Create a ***new node*** and input the ***data*** to the node.
* Change the point of ***next*** of new node to the current ***head node***.
* Point the ***head*** to a new node.

**Insertion at the middle**

* Create a ***new node*** and input the ***data*** to the node.
* Traverse to the node before the ***required position*** where the new node is to be added
* Change ***next pointers*** to include new node in between

**Insertion at the End**

* Create a ***new node*** and input the ***data*** to the node.
* Traverse to the ***last node***
* Change ***next*** of last node to recently created ***new node***

### Deletion

**Deletion at the beginning**

* Change the Point head to the second node

**Deletion at the middle**

* Traverse to the element before the element to be deleted
* Change next pointers to exclude the node from the chain

**Deletion at the End**

- Traverse to second last element
- Change its next pointer to null

### Types of Linked List

* Singly Linked List
* Doubly Linked List
* Circular Linked List

<center>
<img src="{{site.url}}/assets/images/dsa/type-linked-list.png" style="zoom: 5%; background-color:#DCDCDC;" width="80%" height=auto/><br>
<p>Figure 2: Types of Linked List</p> 
</center>

**Singly Linked List** - Each node in this type of linked list has data and a pointer to the next node, like the above case.

**Doubly Linked List** - Each node has data and two pointers, one point to the previous node and the other points to the next node. We can move in both directions.

**Circular Linked List** - The last node is connected to the first node making it a circular linked list. It can be both singly or doubly linked list but with the connection between the last and first node.

**Doubly Linked List Implementation**

```python

        # Doubly Linked List
        # Creating a Node 
        class node:
            def __init__(self, item):
                self.data = item
                self.next = None
                self.prev = None

        # Creating a Doubly Linked List
        class DoublyLL:
            def __init__(self):
                self.head = None
                
            def push(self, element):
                new_node = node(element) # Creating a node with data, prev and next
                new_node.next = self.head # Making the new node as head node
                
                if self.head is not None: # Checking if current head points to null or not
                    self.head.prev = new_node # if not null, then the current node's prev will point to the new node.
                    
                self.head = new_node # New node is assigned as head node
                
            
            def insertAfter(self, prev_node, element):
                new_node = node(element) # Creating a node with data, prev and next
                
                if prev_node is None: # Checking if the previous node after which we are inserting is NULL or not
                    return "the previous node cannot be NULL"
                
                new_node.next = prev_node.next #previous node's next element/node is pointed to new node's next
                prev_node.next = new_node #previous node points to new node
                new_node.prev = prev_node #previous node is pointed back by new_node
                
                if new_node.next is not None: 
                    # Checking if new_node's next is not NULL, then new_node becomes the previous node of the next node of the new_node
                    new_node.next.prev = new_node
                    
            def append(self, element):
                new_node = node(element) # Creating a node with data, prev and next
                
                new_node.next = None #assigning the last node's next as None
                
                if self.head is None: #check if head node is NULL
                    new_node.prev = None #Assigning previous points of new_node as NULL
                    self.head = new_node #Assigning new_node as head of the linked list
                    return
                
                last_node = self.head #assigning head node to variable name last_node!
                while last_node.next != None: #traversing through linked list, unless the next node is None
                    last_node = last_node.next #keep moving to the next node of the linked list
                    
                last_node.next = new_node #after reaching last node, new_node becomes next node of last node
                new_node.prev = last_node #and last node becomes previous node of the new_node
                
                return
            
            def printList(self, node):
        
                print("\nTraversal in forward direction")
                while(node is not None):
                    print(node.data)
                    last = node
                    node = node.next
        
                print("\nTraversal in reverse direction")
                while(last is not None):
                    print(last.data)
                    last = last.prev
                    
        """
        dll = DoublyLL()
        
        dll.push(7)
        
        dll.push(1)
        
        dll.append(4)
        
        dll.insertAfter(dll.head.next, 8)
        
        dll.printList(dll.head)

        Traversal in the forward direction
        1
        7
        8
        4

        Traversal in the reverse direction
        4
        8
        7
        1

        """

```

**Circular Linked List Implementation**

While implementing a circular linked list, make sure to keep track of the last node connected with the first node i.e head node.

```python

        class Node:
            def __init__(self, item):
                self.data = item
                self.next = None
                
        class CircularLL:
            def __init__(self):
                self.head = None
                
            def push(self, element):
                new_node = Node(element)
                temp = self.head
                
                new_node.next = self.head
        
                # If linked list is not None then set the next of
                # last node
                if self.head is not None:
                    while(temp.next != self.head):
                        temp = temp.next
                    temp.next = new_node
        
                else:
                    new_node.next = new_node # For the first node
        
                self.head = new_node

            def append(self, element):
                new_node = Node(element)
                
                if self.head is None:
                    self.head = new_node
                    return
                else:
                    last_node = self.head
                    while last_node.next != self.head:
                        last_node = last_node.next
                        
                last_node.next = new_node
                new_node.next = self.head
                return
            
            def view(self):
                temp = self.head
                if self.head is not None:
                    while(True):
                        print(temp.data)
                        temp = temp.next
                        if (temp == self.head):
                            break

        """
        cll = CircularLL()
        cll.push(6)
        cll.push(9)
        cll.push(5)
        cll.append(23)
        cll.view()

        5
        9
        6
        23
        """

```
In the next blog post, we'll discuss the hash table and its related topic. If you've liked this post, please don't forget to subscribe to the newsletter.