---
layout: data-structure-algorithms
title: Binary Search Tree 
description: Insertion, Deletion and Searching in BST
date:   2021-02-01 13:43:52 +0530
---

In this blog post, we will learn about binary search trees, as the name mentions, BST is widely used for performing search operations over the sorted list of numbers.

Each node in BST has at most two children and BST performs search with time complexity of **O(log(n))** where **n** is the total number of nodes in the BST. To generate a binary search tree from a sorted list of numbers, the tree must follow a set of properties:

* All the left nodes are lesser than the root node
* All the right nodes are greater than the root node
* Sub-trees under each node should follow the same properties as BST.

<center>
<img src="{{site.url}}/assets/images/dsa/bst_invalid.png" style="zoom: 5%; background-color:#DCDCDC;" width="80%" height=auto/><br>
<p>Figure 1: Valid and Invalid Binary Search Tree</p> 
</center>

A tree that has a right subtree with one value smaller than the root is used to demonstrate that it is not a valid binary search tree.

### Basic Operations in BST
* Search
* Insertion
* Deletion

**Node Object**

```python
class Node:
    def __init__(self, value):
        self.data = value
        self.left = None
        self.right = None
```

**Search:** For search operation, the BST follows the divide and conquer strategy, it splits the sorted list into two, one forming the left subtree and the other forming a right subtree. Now based on the number to search, we move either into the left or right subtree. 

<center>
<img src="{{site.url}}/assets/images/dsa/search_bst.png" style="zoom: 5%; background-color:#DCDCDC;" width="80%" height=auto/><br>
<p>Figure 2: Search - Binary Search Tree: Javatpoint</p> 
</center>

**Searching a BST**

* Compare the element with the root of the tree. 
* If the item is matched then return the location of the node. 
* Otherwise check if the item is less than the element present on the root, if so then move to the left sub-tree. 
* If not, then move to the right sub-tree. 
* Repeat this procedure recursively until a match is found. 
* If the element is not found then return None. 

**Insertion:** For insert operation, we must note that the properties of BST are not violated while inserting the element at its appropriate location. 

<center>
<img src="{{site.url}}/assets/images/dsa/insertion_bst.png" style="zoom: 5%; background-color:#DCDCDC;" width="80%" height=auto/><br>
<p>Figure 3: Insertion - Binary Search Tree: Javatpoint</p> 
</center>

**Inserting in BST**

* Allocate the memory for the tree. 
* Set the data part of the node to the value and set the left and right node's object of the tree, point to None. 
* If the item to be inserted, will be the first element of the tree, then the left and right of this node will point to None.
* Else, check if the item is less than the root element of the tree,  if this is true, then recursively perform this operation with the left of the root.
* If this is false, then perform this operation recursively with the right sub-tree of the root.

 **Deletion:** Deleting a node in BST is quite tricky, consider we are deleting an internal node with two child nodes, then we should assign an appropriate parent node to the child node or else if we are deleting a parent node, then we should replace the child node with parent node (that needs to be deleted), then delete the parent node. 

There are three scenarios while deleting the node while simultaneously following the property of BST.

* Node to be deleted as no child node or it's a leaf node
* Node to be deleted as one child node
* Node to be deleted as two child node

**Deletion - Leaf Node:**
<center>
<img src="{{site.url}}/assets/images/dsa/insertion_bst.png" style="zoom: 5%; background-color:#DCDCDC;" width="80%" height=auto/><br>
<p>Figure 4: Deletion: Case: 1 - Javatpoint</p> 
</center>

Simple case, just replace the leaf node with None and free the space allocated to it.

**Deletion - Node with one child**

<center>
<img src="{{site.url}}/assets/images/dsa/insertion_bst.png" style="zoom: 5%; background-color:#DCDCDC;" width="80%" height=auto/><br>
<p>Figure 5: Deletion: Case: 2 - Javatpoint</p> 
</center>

Replace the node to be deleted with the child node and then delete the child node.

**Deletion - Node with two children**
<center>
<img src="{{site.url}}/assets/images/dsa/insertion_bst.png" style="zoom: 5%; background-color:#DCDCDC;" width="80%" height=auto/><br>
<p>Figure 6: Deletion: Case: 3 - Javatpoint</p> 
</center>

It is a little complicated compared to the previous cases. 

* Get the in-order successor or predecessor of the node that needs to be deleted.
* Replace the node with the in-order successor or predecessor
* Remove the in-order successor or predecessor from its original position.

I recommend reading what is **in-order traversal** from the previous blog post to understand what is in-order successor or predecessor.

**Binary Search Tree Implementation**

```python

        class node:
            def __init__(self, item):
                self.item = item
                self.left = None
                self.right = None
                
        def inorderTraversal(root):
            if root is not None:
                inorderTraversal(root.left) 
                
                print(str(root.item) + "->", end=" ")
                
                inorderTraversal(root.right)

        def insertion(node, key):
            if node is None:
                return node(key)
            
            if key < node.item:
                node.left = insertion(node.left, key)
            else:
                node.right = insertion(node.right, key)
                
            return node

        def minimumValueNode(node):
            current = node
            
            while current.left is not None:
                current = current.left
                
            return current

        def deleteNode(root, key):
            
            if root is None:
                return root
            
            if key < root.item:
                root.left = deleteNode(root.left, key)
            elif key > root.item:
                root.right = deleteNode(root.right, key)
            else:
                if root.left is None:
                    temp = root.right
                    root = None
                    return temp
                
                elif root.right is None:
                    temp = root.left
                    root = None
                    return temp
                
                temp = minimumValueNode(root.right)
                root.item = temp.item
                root.right = deleteNode(root.right, temp.item)
                
            return root

        """

        root = None
        root = insertion(root, 8)
        root = insertion(root, 3)
        root = insertion(root, 1)
        root = insertion(root, 6)
        root = insertion(root, 7)
        root = insertion(root, 10)
        root = insertion(root, 14)
        root = insertion(root, 4)

        print("Inorder traversal: ", end=' ')
        inorder(root)

        print("\nDelete 10")
        root = deleteNode(root, 10)
        print("Inorder traversal: ", end=' ')
        inorder(root)
        """
        Inorder traversal:  1-> 3-> 4-> 6-> 7-> 8-> 10-> 14-> 
        Delete 10
        Inorder traversal:  1-> 3-> 4-> 6-> 7-> 8-> 14-> 

```

**Time Complexity**

* Search: Best and Average Case is O(log n), worst case is O(n)
* Insertion: Best and Average Case is O(log n), worst case is O(n)
* Deletion: Best and Average Case is O(log n), worst case is O(n)

where **n** is the number of nodes

**Applications**

* Multilevel indexing in Database
* Dynamic sorting